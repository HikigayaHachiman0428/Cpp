S1
生成数组g[i][j]表示如果我们有礼物i，能不能把j换出来
所以如果 g[i][k] 和 g[k][j] 都是1
就意味着可以先用 i 换到 k 再用 k 换到 j
间接的把 i 换成 j
做一个传递闭包

对于每个人，问自己的i，根据自己的喜好，枚举a[i][j]看能不能把i换成a[i][j]

S2
二分查找
把输入的数组分成两半，各大约20个
枚举所有子集，生成x的和 y的和
假设两部分和分别存在A和B中
分别排序
对于A中的每一个(p.first, p.second)，问B中有多少个(q.first, q.second)
使得 p.first + q.first == gx, p.second + q.second == gy
用两个二分就可以查询出满足条件的个数

S3
注意，一旦folder向下滚动，就再也回不来了
但是email可以滚到最后，通过任意时刻只显示最后k个邮件，回来

直接贪心，如果能把一个email放进folder，那肯定放
如果放不了，那么看当前folder区间的第一个folder，还有没有用
如果再也没有用这个folder的了，就把folder区间向后移动一个
如果还是没有办法，就只要把email的区间向后移动一步，
但这样错过的email只能通过消去最后k个，才能显示出来了
